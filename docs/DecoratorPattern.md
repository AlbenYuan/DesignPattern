# Decorator Pattern
> 动态的为一个对象增加新的功能。装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。


## 角色
* 抽象构件(Component)：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。
* 具体构件(ConcreteComponent)：io流中的FileInputStream、FileOutputStream
* 装饰者(Decorator)：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。
* 具体装饰者(ConcreteDecorator)：负责给构件对象增加新的责任。

## 开发中的使用场景：
* IO中输入流和输出流的设计
* Swing包中图形界面构件功能
* Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper类增强了request对象的功能。
* Struts2中，request，response，session对象的处理

## 优点
* 扩展对象功能，比继承灵活，不会导致类个数急剧增加
* 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象
* 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类

## 缺点：
* 产生很多小对象，大量小对象占据内存，一定程度上影响性能
* 装饰模式易于出错，调试排查比较麻烦

## 比较
* 装饰模式和桥接模式的区别：
  > 两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。
