# Strategy Pattern
策略模式，策略模式定义了一系列的算法，并将每一个算法封装起来。
而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。
策略模式定义和封装了一系列的算法，它们是可以相互替换的，
也就是说它们具有共性，而它们的共性就体现在策略接口的行为上，
另外为了达到最后一句话的目的，也就是说让算法独立于使用它的客户而独立变化，
我们需要让客户端依赖于策略接口。


## 角色
* 环境(Context)角色：持有一个Strategy的引用。
* 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
* 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。

## 应用
* 针对同一类型问题的多种处理方式，仅仅是具体行为有差别时； 
* 需要安全地封装多种同一类型的操作时； 
* 出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。

## 优缺点

### 优点
* 策略模式提供了管理相关的算法族的办法。
  
  策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。
  
* 使用策略模式可以避免使用多重条件(if-else)语句。
  
  多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

### 缺点
* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
  
  这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。

* 对象数量
  
  由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，对应的策略的对象的数目也会增加。